initialize() {
	initializeSLiMOptions(keepPedigrees = T); // Initialize pedigree (to use the relatedness() function)
	defineConstant("MPrs",20); // Define number of mating pairs
	initializeMutationRate(1e-7);
	initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
	initializeMutationType("m2", 0.5, "f", 0.1); // Beneficial
	initializeMutationType("m3", 0.5, "f", -0.1); // Deleterious
	initializeSex("A");
	
	// g1 genomic element type: uses m1 for all mutations
	initializeGenomicElementType("g1", m1, 1.0);
	// g2 genomic element type: uses m1, m2 and m3 mutations
	initializeGenomicElementType("g2", c(m1, m2, m3), c(0.7,0.05,0.2));
	
	// Uniform chromosome of length 100 kb with uniform recombination
	initializeGenomicElement(g1, 0, 29999);
	initializeGenomicElement(g2, 30000, 69999);
	initializeGenomicElement(g1, 70000, 99999);
	initializeRecombinationRate(1e-8);
}

function (s) getPopSumm(o pop, i sampleSize)  
	{
	
	Pop_size = pop.individualCount; 
	if (Pop_size < sampleSize) {    // If the sampleSize is bigger than the size of the population, sampleSize becomes the population size
		sampleSize = Pop_size;
	} 
	mNeutral=sim.mutationTypes[sim.mutationTypes.id==1]; // identifies neutral mutations in the simulation
	i=pop.sampleIndividuals(sampleSize); // samples individuals from the population
	indvCount=length(i);		// returns the length of sampled individuals
	m = i.uniqueMutations;   // obtains the mutations from the sampled individuals
	m_uniq = unique(m);		// obtains the mutations that are unique
	m_uniq=m_uniq[m_uniq.mutationType!=mNeutral];  // removes the neutral mutations
	Mutcount=length(m_uniq);   // counts the unique mutations
	freqMut=sim.mutationFrequencies(pop,m_uniq);   // returns the frequencies of the unique mutations within the population
	ScoefMut=abs(m_uniq.selectionCoeff);   // returns the selection coefficients of the mutations 
	DcoefMut=m_uniq.mutationType.dominanceCoeff; // returns the dominance coefficients of the mutations 
	totalLoad=sum(freqMut*ScoefMut);  // calculates the genetic load by summing the multiplication of the frequenies by the selection coefficients
	relzLoad_homo=sum(freqMut^2*ScoefMut); // calculates the homozygous realised load by summing the multiplication of the frequenies squared by the selection coefficients
	relzLoad_hetero=2*sum(freqMut*(1-freqMut)*ScoefMut*DcoefMut); // calculates the heterozygous realised load by summing the multiplication of the frequenies by by 1-frequencies and by the selection coefficients and by the dominance coefficients
	relzLoad=sum(freqMut^2*ScoefMut)+ (2*sum(freqMut*(1-freqMut)*ScoefMut*DcoefMut)); // calculates the realised load by adding to the homozygous realised load to the heterozygous realised load
	mskLoad=sum(freqMut*ScoefMut) - sum(freqMut^2*ScoefMut) - (2*sum(freqMut*(1-freqMut)*ScoefMut*DcoefMut)); // calculates the masked load by subtrating the realised load from the genetic load
	
	fitness_indv=c(); // creates empty array to store individual fitness
	for(indv in pop.individuals){  // goes through each individual
		// Calculate individual fitness
		muts0_m2 = indv.genomes[0].mutations;  // obtains the mutations of each chromosome in each individuals
		muts1_m2 = indv.genomes[1].mutations;
		HOMO_m2=setIntersection(muts0_m2,muts1_m2);  // mutations cross referenced to determine whether they are homozoygous or heterozyoous
		HETERO_m2=setSymmetricDifference(muts0_m2,muts1_m2);
		if(length(HETERO_m2)>0){fit_hetero=1-(abs(HETERO_m2.selectionCoeff)*HETERO_m2.mutationType.dominanceCoeff);}
		if(length(HETERO_m2)==0){fit_hetero=1;}  // calculates the reduction in fitness contributed to by heteorzygous or homozygous mutations if any
		fit_homo=1-abs(HOMO_m2.selectionCoeff); 
		if(length(fit_homo)==0){fit_homo=1;}
		indv_fit=product(c(fit_hetero,fit_homo)); // calculates the fitness of the individual by obtaining the product of the fitness deficit of the heterozygous and homozygous mutations
		fitness_indv=c(fitness_indv,indv_fit); // adds the individual's fitness to the array
	}
	
	fitness_cached=pop.cachedFitness(pop.individuals.index);
	
	
	out=sim.generation +"\t"+ pop.id +"\t"+ indvCount +"\t"+ Mutcount +"\t"+ Pop_size +"\t"+ "NA" +"\t"+ totalLoad +"\t"+ relzLoad +"\t"+ relzLoad_homo +"\t"+ relzLoad_hetero +"\t"+ mskLoad +"\t"+mean(fitness_indv)+"\t"+sd(fitness_indv)+"\t"+mean(fitness_cached)+"\t"+sd(fitness_cached);
	return(out);
}

// Create a population of 500 individuals
1 early() {
	sim.addSubpop("p1", 500);
}

1000: early() {
	getPopSumm(p1, 100);
}

// Add early event where we select the pairs of males and females
1000: early() {
	inds = p1.individuals;
	// Subset males and females from the population
	fems = inds[inds.sex=="F"];
	mans = inds[inds.sex=="M"];
	p1.individuals.tag = 0; // Tag all individuals with a 0
	
	// Create groups of mothers and fathers
	mothers = c();
	fathers = c();
	// Select 20 breeding pairs
	for (m in 0:(MPrs-1)) {
		// Select one male and female from the males and females
		mother = sample(fems,1, replace = F);
		father = sample(mans,1, replace = F);
		// Add the female to "mothers" and the male to the "fathers"
		mothers = c(mothers,mother);
		fathers = c(fathers,father);
		
		// Remove the mother and father from their respective pools of possible parents
		fems = fems[fems.index!=mother.index];
		mans = mans[mans.index!=father.index];
	}
	// Tag mothers and fathers with unique numbers to ensure they remain in the correct order
	mothers.tag = c(1:MPrs);
	fathers.tag = c(1:MPrs);
}

// Mate-choice callback
1000: mateChoice() {
	if (individual.tag == 0) {
		// If the female has no tag, return no mating probability
		return float(0);
	} else {
		// If the female has a tag, select the male with the same tag
		males = p1.individuals[p1.individuals.sex == "M"]; // Get all males
		matchingMale = males[males.tag == individual.tag];
		
		return(matchingMale[0]);
	}
}

c(1000, 2000) late() {
	// Print mean heterozygosity across the population
	heterozygosity = calcHeterozygosity(p1.genomes);
	cat("Mean heterozygosity = " + heterozygosity + "\n");
}
