initialize() {
	initializeSLiMOptions(keepPedigrees = T); // Initialize pedigree (to use the relatedness() function)
	defineConstant("MPrs",20); // Define number of mating pairs
	initializeMutationRate(1e-7);
	initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
	initializeMutationType("m2", 0.5, "f", 0.1); // Beneficial
	initializeMutationType("m3", 0.5, "f", -0.1); // Deleterious
	initializeSex("A");
	
	// g1 genomic element type: uses m1 for all mutations
	initializeGenomicElementType("g1", m1, 1.0);
	// g2 genomic element type: uses m1, m2 and m3 mutations
	initializeGenomicElementType("g2", c(m1, m2, m3), c(0.7,0.05,0.2));
	
	// Uniform chromosome of length 100 kb with uniform recombination
	initializeGenomicElement(g1, 0, 29999);
	initializeGenomicElement(g2, 30000, 69999);
	initializeGenomicElement(g1, 70000, 99999);
	initializeRecombinationRate(1e-8);
}

// Create a population of 500 individuals
1 early() {
	sim.addSubpop("p1", 500);
}

// Add early event where we select the pairs of males and females
1000: early() {
	inds = p1.individuals;
	// Subset males and females from yinds
	fems = inds[inds.sex=="F"];			
	mans = inds[inds.sex=="M"];
	p1.individuals.tag = 0; // Tag all individuals with a 0
	
	// Create groups of mothers and fathers
	mothers = c();
	fathers = c();
	for (m in 0:(MPrs-1)) {
		// Select one male and female from the males and females
		mother = sample(fems,1, replace = F);  
		father = sample(mans,1, replace = F);
		// Add the female to "mothers" and the male to the "fathers"
		mothers = c(mothers,mother);
		fathers = c(fathers,father);
		
		// Remove the mother and father from their respective pools of possible parents
		fems = fems[fems.index!=mother.index]; 
		mans = mans[mans.index!=father.index];
	}
	// Tag mothers and fathers with unique numbers to ensure they remain in the correct order
	mothers.tag = c(1:MPrs);
	fathers.tag = c(1:MPrs);
}

// Mate-choice callback
1000: mateChoice() {
	if (individual.tag == 0) {
		// If the female has no tag, return no mating probability
		return float(0);
	} else {
		// If the female has a tag, select the male with the same tag
		males = p1.individuals[p1.individuals.sex == "M"]; // Get all males
		matchingMale = males[males.tag == individual.tag];
		
		return(matchingMale[0]);	
	}
}

c(1000, 2000) late() {
	// Print mean heterozygosity across the population
	heterozygosity = calcHeterozygosity(p1.genomes);
	cat("Mean heterozygosity = " + heterozygosity + "\n");
}
