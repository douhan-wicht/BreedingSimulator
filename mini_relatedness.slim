initialize() {
	initializeSLiMOptions(keepPedigrees = T); // Allows us to access the relatedness() method
	defineConstant("MPrs",20); // Define number of mating pairs
	initializeMutationRate(1.8e-7); // Mutation rate
	initializeMutationType("m1", 0.5, "f", 0.0); // Neutral mutation
	initializeMutationType("m2", 0.5, "f", -0.1); // Deleterious mutation
	initializeMutationType("m3", 0.5, "f", 0.1); // Beneficial mutation
	initializeMutationType("m4", 0.5, "f", 0.0); // Neutral mutation, exons
	initializeGenomicElementType("g1", c(m1), 1.0); // Intron
	initializeGenomicElementType("g2", c(m2, m3, m4), c(0.7, 0.2, 0.05));
	initializeGenomicElement(g1, 0, 39999);  // Intron, 40 kB
	initializeGenomicElement(g2, 40000, 59999); // Exon, 20 kB
	initializeGenomicElement(g1, 60000, 99999); // Intron, 40kB
	initializeRecombinationRate(4e-8);   // Recombination rate
	initializeSex("A"); // Initialize sex on autosome chromosome
}

// create a population of 500 individuals
1 early() {
	sim.addSubpop("p1", 500);
}

// Add early event where we select the pairs of males and females from different broods
1000: early() {
	inds = p1.individuals;
	// Subset males and females from the population
	fems = inds[inds.sex=="F"];
	mans = inds[inds.sex=="M"];
	p1.individuals.tag = 0; // Tag all individuals with a 0
	
	// Initialize mothers and fathers as empty vectors
	mothers = c();
	fathers = c();
	brood_ids = asInteger(c());
	invalid_mothers_selected = 0;
	invalid_fathers_selected = 0;
	
	
	while (size(mothers) < MPrs & size(fathers) < MPrs) {
		available_fems = c();
		available_mans = c();
		
		// Select one female
		for (fem in fems){
			matching_ids_fem = setIntersection(fem.pedigreeParentIDs, brood_ids);
			if (size(matching_ids_fem) == 0){
				available_fems = c(available_fems, fem);
			}
		}
		cat("Size of available_fems: " + size(available_fems) + "\n");
		
		// Filtering females
		if (size(available_fems) > 0){
			mother = sample(available_fems, 1, replace = F);
		} else {
			mother = sample(fems, 1, replace = F); // If no mother from unique brood found, pick randomly
			invalid_mothers_selected = invalid_mothers_selected + 1;
		}
		brood_ids = c(brood_ids, mother.pedigreeParentIDs); // Update brood list for mothers
		fems = fems[fems.index != mother.index]; // Ensure removal from main pool		
		
		// Filtering males
		for (man in mans){
			matching_ids_man = setIntersection(man.pedigreeParentIDs, brood_ids);
			if (size(matching_ids_man) == 0) {
				available_mans = c(available_mans, man);
			}
		}
		cat("Size of available_mans: " + size(available_mans) + "\n");
		// Selecting males	
		if (size(available_mans) != 0){
			iteration_count = 0;
			while (T) {
				iteration_count = iteration_count + 1;
				if (iteration_count > 100) {
					cat("Infinite loop detected while selecting father. Breaking loop1.\n");
					break;
				}
				father = sample(available_mans, 1, replace = F);
				if (father.pedigreeParentIDs[1] != mother.pedigreeParentIDs[1]) {
					break;
				}
			}
		} else {
			iteration_count = 0;
			while (T) {
				iteration_count = iteration_count + 1;
				if (iteration_count > 100) {
					cat("Infinite loop detected while selecting father. Breaking loop2.\n");
					break;
				}
				father = sample(mans, 1, replace = F);
				if (father.pedigreeParentIDs[1] != mother.pedigreeParentIDs[1]) {
					break;
				}
			}
			invalid_fathers_selected = invalid_fathers_selected + 1;
		}
		
		// Populate the father brood IDs vector
		brood_ids = c(brood_ids, father.pedigreeParentIDs);
		mans = mans[mans.index != father.index]; // Ensure removal from main pool
		
		// Add the female to "mothers" and the male to the "fathers"
		mothers = c(mothers, mother);
		fathers = c(fathers, father);
			
	}
	
	// Tag mothers and fathers with unique numbers to ensure they remain in the correct order
	
	for (i in 0:(size(mothers)-1)) {
		mothers[i].tag = i+1;
	}
	for (i in 0:(size(fathers)-1)) {
		fathers[i].tag = i+1;
	}
	cat("Number of mothers:" + size(mothers));
	cat("Number of fathers:" + size(fathers));
	cat("Invalid mothers selected (non-unique brood): " + invalid_mothers_selected + ".\n");
	cat("Invalid fathers selected (non-unique brood): " + invalid_fathers_selected + ".\n");

}

// Mate-choice callback
1000: mateChoice() {
	if (individual.tag == 0) {
		// If the female has no tag, return no mating probability
		return float(0);
	} else {
		// If the female has a tag, select the male with the same tag
		males = p1.individuals[p1.individuals.sex == "M"]; // Get all males
		matchingMale = males[males.tag == individual.tag];
		
		return(matchingMale[0]);
	
	}
}

c(1000, 2000) late() {
	// Print mean heterozygosity across the population
	heterozygosity = calcHeterozygosity(p1.genomes);
	cat("Mean heterozygosity = " + heterozygosity + "\n");
}
